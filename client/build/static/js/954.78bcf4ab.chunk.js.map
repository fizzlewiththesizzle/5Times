{"version":3,"file":"static/js/954.78bcf4ab.chunk.js","mappings":"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","sources":["../node_modules/embla-carousel-autoplay/src/components/Options.ts","../node_modules/embla-carousel-autoplay/src/components/Autoplay.ts","../node_modules/embla-carousel-reactive-utils/src/components/utils.ts","../node_modules/embla-carousel/src/components/utils.ts","../node_modules/embla-carousel/src/components/Limit.ts","../node_modules/embla-carousel/src/components/Counter.ts","../node_modules/embla-carousel/src/components/EventStore.ts","../node_modules/embla-carousel/src/components/DragHandler.ts","../node_modules/embla-carousel/src/components/DragTracker.ts","../node_modules/embla-carousel/src/components/ResizeHandler.ts","../node_modules/embla-carousel/src/components/ScrollBounds.ts","../node_modules/embla-carousel/src/components/ScrollLooper.ts","../node_modules/embla-carousel/src/components/ScrollTarget.ts","../node_modules/embla-carousel/src/components/Vector1d.ts","../node_modules/embla-carousel/src/components/Translate.ts","../node_modules/embla-carousel/src/components/SlideLooper.ts","../node_modules/embla-carousel/src/components/SlidesHandler.ts","../node_modules/embla-carousel/src/components/SlidesInView.ts","../node_modules/embla-carousel/src/components/SlidesToScroll.ts","../node_modules/embla-carousel/src/components/Engine.ts","../node_modules/embla-carousel/src/components/NodeRects.ts","../node_modules/embla-carousel/src/components/Direction.ts","../node_modules/embla-carousel/src/components/Axis.ts","../node_modules/embla-carousel/src/components/PercentOfView.ts","../node_modules/embla-carousel/src/components/Alignment.ts","../node_modules/embla-carousel/src/components/SlideSizes.ts","../node_modules/embla-carousel/src/components/ScrollSnaps.ts","../node_modules/embla-carousel/src/components/ScrollContain.ts","../node_modules/embla-carousel/src/components/ScrollLimit.ts","../node_modules/embla-carousel/src/components/ScrollBody.ts","../node_modules/embla-carousel/src/components/ScrollTo.ts","../node_modules/embla-carousel/src/components/ScrollProgress.ts","../node_modules/embla-carousel/src/components/SlideRegistry.ts","../node_modules/embla-carousel/src/components/SlideFocus.ts","../node_modules/embla-carousel/src/components/Options.ts","../node_modules/embla-carousel/src/components/OptionsHandler.ts","../node_modules/embla-carousel/src/components/EmblaCarousel.ts","../node_modules/embla-carousel/src/components/PluginsHandler.ts","../node_modules/embla-carousel/src/components/EventHandler.ts","../node_modules/embla-carousel/src/components/Animations.ts","../node_modules/embla-carousel-react/src/components/useEmblaCarousel.ts"],"sourcesContent":["import { CreateOptionsType } from 'embla-carousel/components/Options'\n\nexport type OptionsType = CreateOptionsType<{\n  delay: number\n  jump: boolean\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  stopOnLastSnap: boolean\n  rootNode: ((emblaRoot: HTMLElement) => HTMLElement | null) | null\n}>\n\nexport const defaultOptions: OptionsType = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n}\n","import { OptionsType, defaultOptions } from './Options'\nimport { CreatePluginType } from 'embla-carousel/components/Plugins'\nimport { OptionsHandlerType } from 'embla-carousel/components/OptionsHandler'\nimport { EmblaCarouselType } from 'embla-carousel'\n\ndeclare module 'embla-carousel/components/Plugins' {\n  interface EmblaPluginsType {\n    autoplay?: AutoplayType\n  }\n}\n\ndeclare module 'embla-carousel/components/EventHandler' {\n  interface EmblaEventListType {\n    autoplayPlay: 'autoplay:play'\n    autoplayStop: 'autoplay:stop'\n  }\n}\n\nexport type AutoplayType = CreatePluginType<\n  {\n    play: (jump?: boolean) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoplayOptionsType = AutoplayType['options']\n\nfunction Autoplay(userOptions: AutoplayOptionsType = {}): AutoplayType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let playing = false\n  let resume = true\n  let jump = false\n  let animationFrame = 0\n  let timer = 0\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    jump = options.jump\n    destroyed = false\n\n    const { eventStore, ownerDocument } = emblaApi.internalEngine()\n    const emblaRoot = emblaApi.rootNode()\n    const root = (options.rootNode && options.rootNode(emblaRoot)) || emblaRoot\n\n    emblaApi.on('pointerDown', clearTimer)\n\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startTimer)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false\n        clearTimer()\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true\n          startTimer()\n        })\n      }\n    }\n\n    if (options.stopOnFocusIn) {\n      eventStore.add(root, 'focusin', clearTimer)\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'focusout', startTimer)\n      }\n    }\n\n    eventStore.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.visibilityState === 'hidden') {\n        resume = playing\n        return clearTimer()\n      }\n\n      if (resume) startTimer()\n    })\n\n    if (options.playOnInit) {\n      emblaApi.on('init', startTimer).on('reInit', startTimer)\n    }\n  }\n\n  function destroy(): void {\n    destroyed = true\n    playing = false\n    emblaApi.off('init', startTimer).off('reInit', startTimer)\n    emblaApi.off('pointerDown', clearTimer)\n    if (!options.stopOnInteraction) emblaApi.off('pointerUp', startTimer)\n    clearTimer()\n    cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  function startTimer(): void {\n    if (destroyed) return\n    if (!resume) return\n    if (!playing) emblaApi.emit('autoplay:play')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = ownerWindow.setInterval(next, options.delay)\n    playing = true\n  }\n\n  function clearTimer(): void {\n    if (destroyed) return\n    if (playing) emblaApi.emit('autoplay:stop')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = 0\n    playing = false\n  }\n\n  function play(jumpOverride?: boolean): void {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride\n    resume = true\n    startTimer()\n  }\n\n  function stop(): void {\n    if (playing) clearTimer()\n  }\n\n  function reset(): void {\n    if (playing) play()\n  }\n\n  function isPlaying(): boolean {\n    return playing\n  }\n\n  function next(): void {\n    animationFrame = requestAnimationFrame(() => {\n      const { index } = emblaApi.internalEngine()\n      const nextIndex = index.clone().add(1).get()\n      const lastIndex = emblaApi.scrollSnapList().length - 1\n      const kill = options.stopOnLastSnap && nextIndex === lastIndex\n\n      if (kill) clearTimer()\n\n      if (emblaApi.canScrollNext()) {\n        emblaApi.scrollNext(jump)\n      } else {\n        emblaApi.scrollTo(0, jump)\n      }\n    })\n  }\n\n  const self: AutoplayType = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\nAutoplay.globalOptions = <AutoplayOptionsType | undefined>undefined\n\nexport default Autoplay\n","import { EmblaPluginType } from 'embla-carousel'\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isRecord(\n  subject: unknown\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || Array.isArray(subject)\n}\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areOptionsEqual(\n  optionsA: Record<string, unknown>,\n  optionsB: Record<string, unknown>\n): boolean {\n  const optionsAKeys = Object.keys(optionsA)\n  const optionsBKeys = Object.keys(optionsB)\n\n  if (optionsAKeys.length !== optionsBKeys.length) return false\n\n  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}))\n  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}))\n\n  if (breakpointsA !== breakpointsB) return false\n\n  return optionsAKeys.every((key) => {\n    const valueA = optionsA[key]\n    const valueB = optionsB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return areOptionsEqual(valueA, valueB)\n  })\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[]\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[]\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areOptionsEqual(optionA, optionB)\n  })\n}\n","import { PointerEventType } from './DragTracker'\n\nexport type WindowType = Window & typeof globalThis\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isString(subject: unknown): subject is string {\n  return typeof subject === 'string'\n}\n\nexport function isBoolean(subject: unknown): subject is boolean {\n  return typeof subject === 'boolean'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return Math.sign(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function arrayIsLastIndex<Type>(array: Type[], index: number): boolean {\n  return index === arrayLastIndex(array)\n}\n\nexport function arrayFromNumber(n: number, startAt: number = 0): number[] {\n  return Array.from(Array(n), (_, i) => startAt + i)\n}\n\nexport function objectKeys<Type extends object>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function isMouseEvent(\n  evt: PointerEventType,\n  ownerWindow: WindowType\n): evt is MouseEvent {\n  return (\n    typeof ownerWindow.MouseEvent !== 'undefined' &&\n    evt instanceof ownerWindow.MouseEvent\n  )\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number = 0, max: number = 0): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean\n): CounterType {\n  const { constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return clone().set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    get,\n    set,\n    add,\n    clone\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType\n  ) => EventStoreType\n  clear: () => void\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true }\n  ): EventStoreType {\n    let removeListener: EventRemoverType\n\n    if ('addEventListener' in node) {\n      node.addEventListener(type, handler, options)\n      removeListener = () => node.removeEventListener(type, handler, options)\n    } else {\n      const legacyMediaQueryList = <MediaQueryList>node\n      legacyMediaQueryList.addListener(handler)\n      removeListener = () => legacyMediaQueryList.removeListener(handler)\n    }\n\n    listeners.push(removeListener)\n    return self\n  }\n\n  function clear(): void {\n    listeners = listeners.filter((remove) => remove())\n  }\n\n  const self: EventStoreType = {\n    add,\n    clear\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { AnimationType } from './Animations'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1DType } from './Vector1d'\nimport { PercentOfViewType } from './PercentOfView'\nimport { Limit } from './Limit'\nimport {\n  deltaAbs,\n  factorAbs,\n  isBoolean,\n  isMouseEvent,\n  mathAbs,\n  mathSign,\n  WindowType\n} from './utils'\n\ntype DragHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: PointerEventType\n) => boolean | void\n\nexport type DragHandlerOptionType = boolean | DragHandlerCallbackType\n\nexport type DragHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n  pointerDown: () => boolean\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  dragFree: boolean,\n  dragThreshold: number,\n  skipSnaps: boolean,\n  baseFriction: number,\n  watchDrag: DragHandlerOptionType\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const initEvents = EventStore()\n  const dragEvents = EventStore()\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20))\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 43 : 25\n\n  let isMoving = false\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchDrag) return\n\n    function downIfAllowed(evt: PointerEventType): void {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt)\n    }\n\n    const node = rootNode\n    initEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', () => undefined, nonPassiveEvent)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', downIfAllowed)\n      .add(node, 'mousedown', downIfAllowed)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function destroy(): void {\n    initEvents.clear()\n    dragEvents.clear()\n  }\n\n  function addDragEvents(): void {\n    const node = isMouse ? ownerDocument : rootNode\n    dragEvents\n      .add(node, 'touchmove', move, nonPassiveEvent)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const nodeName = node.nodeName || ''\n    return focusNodes.includes(nodeName)\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.add(mathSign(force) * -1)\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow)\n    isMouse = isMouseEvt\n    if (isMouseEvt && evt.button !== 0) return\n    if (isFocusNode(evt.target as Element)) return\n\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving\n    isMoving = deltaAbs(target.get(), location.get()) >= 2\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    scrollBody.useFriction(0).useDuration(0)\n    target.set(location)\n    addDragEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n  }\n\n  function move(evt: PointerEventType): void {\n    const lastScroll = dragTracker.readPoint(evt)\n    const lastCross = dragTracker.readPoint(evt, crossAxis)\n    const diffScroll = deltaAbs(lastScroll, startScroll)\n    const diffCross = deltaAbs(lastCross, startCross)\n\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (diffScroll > dragThreshold) preventClick = true\n\n    scrollBody.useFriction(0.3).useDuration(1)\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const speed = baseSpeed - 10 * forceFactor\n    const friction = baseFriction + forceFactor / 50\n\n    preventScroll = false\n    pointerIsDown = false\n    dragEvents.clear()\n    scrollBody.useDuration(speed).useFriction(friction)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n    }\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    init,\n    pointerDown,\n    destroy\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { isMouseEvent, mathAbs, WindowType } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  ownerWindow: WindowType\n): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { NodeRectsType } from './NodeRects'\nimport { isBoolean, mathAbs, WindowType } from './utils'\n\ntype ResizeHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  entries: ResizeObserverEntry[]\n) => boolean | void\n\nexport type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType\n\nexport type ResizeHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function ResizeHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  ownerWindow: WindowType,\n  slides: HTMLElement[],\n  axis: AxisType,\n  watchResize: ResizeHandlerOptionType,\n  nodeRects: NodeRectsType\n): ResizeHandlerType {\n  let resizeObserver: ResizeObserver\n  let containerSize: number\n  let slideSizes: number[] = []\n  let destroyed = false\n\n  function readSize(node: HTMLElement): number {\n    return axis.measureSize(nodeRects.measure(node))\n  }\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchResize) return\n\n    containerSize = readSize(container)\n    slideSizes = slides.map(readSize)\n\n    function defaultCallback(entries: ResizeObserverEntry[]): void {\n      for (const entry of entries) {\n        const isContainer = entry.target === container\n        const slideIndex = slides.indexOf(<HTMLElement>entry.target)\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex]\n        const newSize = readSize(isContainer ? container : slides[slideIndex])\n        const diffSize = mathAbs(newSize - lastSize)\n\n        if (diffSize >= 0.5) {\n          ownerWindow.requestAnimationFrame(() => {\n            emblaApi.reInit()\n            eventHandler.emit('resize')\n          })\n          break\n        }\n      }\n    }\n\n    resizeObserver = new ResizeObserver((entries) => {\n      if (destroyed) return\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries)\n      }\n    })\n\n    const observeNodes = [container].concat(slides)\n    observeNodes.forEach((node) => resizeObserver.observe(node))\n  }\n\n  function destroy(): void {\n    if (resizeObserver) resizeObserver.disconnect()\n    destroyed = true\n  }\n\n  const self: ResizeHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const frictionLimit = Limit(0.1, 0.99)\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useDuration(25).useBaseFriction()\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  offsetLocation: Vector1DType,\n  vectors: Vector1DType[]\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(offsetLocation.get())\n    if (direction === -1) return reachedMin(offsetLocation.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { arrayLast, mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    if (matchingTargets.length) return minDistance(matchingTargets)\n    return arrayLast(targets) - contentSize\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (n: Vector1DType | number) => void\n  add: (n: Vector1DType | number) => void\n  subtract: (n: Vector1DType | number) => void\n}\n\nexport function Vector1D(initialValue: number): Vector1DType {\n  let value = initialValue\n\n  function get(): number {\n    return value\n  }\n\n  function set(n: Vector1DType | number): void {\n    value = normalizeInput(n)\n  }\n\n  function add(n: Vector1DType | number): void {\n    value += normalizeInput(n)\n  }\n\n  function subtract(n: Vector1DType | number): void {\n    value -= normalizeInput(n)\n  }\n\n  function normalizeInput(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    get,\n    set,\n    add,\n    subtract\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (target: number) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: number): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype SlideBoundType = {\n  start: number\n  end: number\n}\n\ntype LoopPointType = {\n  loopPoint: number\n  index: number\n  translate: TranslateType\n  slideLocation: Vector1DType\n  target: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  slideSizesWithGaps: number[],\n  snaps: number[],\n  scrollSnaps: number[],\n  offsetLocation: Vector1DType,\n  slides: HTMLElement[]\n): SlideLooperType {\n  const roundingSafety = 0.5\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findSlideBounds(offset: number): SlideBoundType[] {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }))\n  }\n\n  function findLoopPoints(\n    indexes: number[],\n    offset: number,\n    isEndEdge: boolean\n  ): LoopPointType[] {\n    const slideBounds = findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize\n      const altered = isEndEdge ? contentSize : 0\n      const boundEdge = isEndEdge ? 'end' : 'start'\n      const loopPoint = slideBounds[index][boundEdge]\n\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, direction, slides[index]),\n        target: () => (offsetLocation.get() > loopPoint ? initial : altered)\n      }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0]\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, contentSize, false)\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, -contentSize, true)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, slideLocation } = loopPoint\n      const shiftLocation = target()\n      if (shiftLocation === slideLocation.get()) return\n      translate.to(shiftLocation)\n      slideLocation.set(shiftLocation)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { isBoolean } from './utils'\n\ntype SlidesHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  mutations: MutationRecord[]\n) => boolean | void\n\nexport type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType\n\nexport type SlidesHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function SlidesHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  watchSlides: SlidesHandlerOptionType\n): SlidesHandlerType {\n  let mutationObserver: MutationObserver\n  let destroyed = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchSlides) return\n\n    function defaultCallback(mutations: MutationRecord[]): void {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          emblaApi.reInit()\n          eventHandler.emit('slidesChanged')\n          break\n        }\n      }\n    }\n\n    mutationObserver = new MutationObserver((mutations) => {\n      if (destroyed) return\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations)\n      }\n    })\n\n    mutationObserver.observe(container, { childList: true })\n  }\n\n  function destroy(): void {\n    if (mutationObserver) mutationObserver.disconnect()\n    destroyed = true\n  }\n\n  const self: SlidesHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EventHandlerType } from './EventHandler'\nimport { objectKeys } from './utils'\n\ntype IntersectionEntryMapType = {\n  [key: number]: IntersectionObserverEntry\n}\n\nexport type SlidesInViewOptionsType = IntersectionObserverInit['threshold']\n\nexport type SlidesInViewType = {\n  init: () => void\n  destroy: () => void\n  get: (inView?: boolean) => number[]\n}\n\nexport function SlidesInView(\n  container: HTMLElement,\n  slides: HTMLElement[],\n  eventHandler: EventHandlerType,\n  threshold: SlidesInViewOptionsType\n): SlidesInViewType {\n  const intersectionEntryMap: IntersectionEntryMapType = {}\n  let inViewCache: number[] | null = null\n  let notInViewCache: number[] | null = null\n  let intersectionObserver: IntersectionObserver\n  let destroyed = false\n\n  function init(): void {\n    intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        if (destroyed) return\n\n        entries.forEach((entry) => {\n          const index = slides.indexOf(<HTMLElement>entry.target)\n          intersectionEntryMap[index] = entry\n        })\n\n        inViewCache = null\n        notInViewCache = null\n        eventHandler.emit('slidesInView')\n      },\n      {\n        root: container.parentElement,\n        threshold\n      }\n    )\n\n    slides.forEach((slide) => intersectionObserver.observe(slide))\n  }\n\n  function destroy(): void {\n    if (intersectionObserver) intersectionObserver.disconnect()\n    destroyed = true\n  }\n\n  function createInViewList(inView: boolean): number[] {\n    return objectKeys(intersectionEntryMap).reduce(\n      (list: number[], slideIndex) => {\n        const index = parseInt(slideIndex)\n        const { isIntersecting } = intersectionEntryMap[index]\n        const inViewMatch = inView && isIntersecting\n        const notInViewMatch = !inView && !isIntersecting\n\n        if (inViewMatch || notInViewMatch) list.push(index)\n        return list\n      },\n      []\n    )\n  }\n\n  function get(inView: boolean = true): number[] {\n    if (inView && inViewCache) return inViewCache\n    if (!inView && notInViewCache) return notInViewCache\n\n    const slideIndexes = createInViewList(inView)\n\n    if (inView) inViewCache = slideIndexes\n    if (!inView) notInViewCache = slideIndexes\n\n    return slideIndexes\n  }\n\n  const self: SlidesInViewType = {\n    init,\n    destroy,\n    get\n  }\n\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { NodeRectType } from './NodeRects'\nimport {\n  arrayKeys,\n  arrayLast,\n  arrayLastIndex,\n  isNumber,\n  mathAbs\n} from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  slidesToScroll: SlidesToScrollOptionType,\n  loop: boolean,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  startGap: number,\n  endGap: number,\n  pixelTolerance: number\n): SlidesToScrollType {\n  const { startEdge, endEdge } = axis\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    if (!array.length) return []\n\n    return arrayKeys(array)\n      .reduce((groups: number[], rectB) => {\n        const rectA = arrayLast(groups) || 0\n        const isFirst = rectA === 0\n        const isLast = rectB === arrayLastIndex(array)\n\n        const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge]\n        const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge]\n        const gapA = !loop && isFirst ? direction.apply(startGap) : 0\n        const gapB = !loop && isLast ? direction.apply(endGap) : 0\n        const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA))\n\n        if (chunkSize > viewSize + pixelTolerance) groups.push(rectB)\n        if (isLast) groups.push(array.length)\n        return groups\n      }, [])\n      .map((currentSize, index, groups) => {\n        const previousSize = Math.max(groups[index - 1] || 0)\n        return array.slice(previousSize, currentSize)\n      })\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { NodeRectType, NodeRects } from './NodeRects'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ResizeHandler, ResizeHandlerType } from './ResizeHandler'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { SlideRegistry, SlideRegistryType } from './SlideRegistry'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideFocus, SlideFocusType } from './SlideFocus'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesHandler, SlidesHandlerType } from './SlidesHandler'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex, WindowType } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport {\n  AnimationType,\n  AnimationUpdateType,\n  AnimationsType,\n  AnimationRenderType\n} from './Animations'\n\nexport type EngineType = {\n  ownerDocument: Document\n  ownerWindow: WindowType\n  eventHandler: EventHandlerType\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  offsetLocation: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  resizeHandler: ResizeHandlerType\n  slidesHandler: SlidesHandlerType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnapList: number[]\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  slideFocus: SlideFocusType\n  slideRegistry: SlideRegistryType['slideRegistry']\n  containerRect: NodeRectType\n  slideRects: NodeRectType[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n  animations: AnimationsType\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag\n  } = options\n\n  // Measurements\n  const pixelTolerance = 2\n  const nodeRects = NodeRects()\n  const containerRect = nodeRects.measure(container)\n  const slideRects = slides.map(nodeRects.measure)\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && !!containScroll\n  const readEdgeGap = loop || !!containScroll\n  const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n    ownerWindow\n  )\n  const slidesToScroll = SlidesToScroll(\n    axis,\n    direction,\n    viewSize,\n    groupSlides,\n    loop,\n    containerRect,\n    slideRects,\n    startGap,\n    endGap,\n    pixelTolerance\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slidesToScroll\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained, scrollContainLimit } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n    pixelTolerance\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Animation\n  const update: AnimationUpdateType = ({\n    dragHandler,\n    scrollBody,\n    scrollBounds,\n    options: { loop }\n  }) => {\n    if (!loop) scrollBounds.constrain(dragHandler.pointerDown())\n    scrollBody.seek()\n  }\n\n  const render: AnimationRenderType = (\n    {\n      scrollBody,\n      translate,\n      location,\n      offsetLocation,\n      scrollLooper,\n      slideLooper,\n      dragHandler,\n      animation,\n      eventHandler,\n      options: { loop }\n    },\n    lagOffset\n  ) => {\n    const velocity = scrollBody.velocity()\n    const hasSettled = scrollBody.settled()\n\n    if (hasSettled && !dragHandler.pointerDown()) {\n      animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!hasSettled) eventHandler.emit('scroll')\n\n    offsetLocation.set(location.get() - velocity + velocity * lagOffset)\n\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction())\n      slideLooper.loop()\n    }\n\n    translate.to(offsetLocation.get())\n  }\n\n  const animation: AnimationType = {\n    start: () => animations.start(engine),\n    stop: () => animations.stop(engine),\n    update: () => update(engine),\n    render: (lagOffset: number) => render(engine, lagOffset)\n  }\n\n  // Shared\n  const friction = 0.68\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const offsetLocation = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(\n    location,\n    offsetLocation,\n    target,\n    duration,\n    friction\n  )\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler\n  )\n  const scrollProgress = ScrollProgress(limit)\n  const eventStore = EventStore()\n  const slidesInView = SlidesInView(\n    container,\n    slides,\n    eventHandler,\n    inViewThreshold\n  )\n  const { slideRegistry } = SlideRegistry(\n    containSnaps,\n    containScroll,\n    scrollSnaps,\n    scrollContainLimit,\n    slidesToScroll,\n    slideIndexes\n  )\n  const slideFocus = SlideFocus(\n    root,\n    slides,\n    slideRegistry,\n    scrollTo,\n    scrollBody,\n    eventStore\n  )\n\n  // Engine\n  const engine: EngineType = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler: DragHandler(\n      axis,\n      direction,\n      root,\n      ownerDocument,\n      ownerWindow,\n      target,\n      DragTracker(axis, ownerWindow),\n      location,\n      animation,\n      scrollTo,\n      scrollBody,\n      scrollTarget,\n      index,\n      eventHandler,\n      percentOfView,\n      dragFree,\n      dragThreshold,\n      skipSnaps,\n      friction,\n      watchDrag\n    ),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    options,\n    resizeHandler: ResizeHandler(\n      container,\n      eventHandler,\n      ownerWindow,\n      slides,\n      axis,\n      watchResize,\n      nodeRects\n    ),\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n      location,\n      offsetLocation,\n      target\n    ]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizes,\n      slideSizesWithGaps,\n      snaps,\n      scrollSnaps,\n      offsetLocation,\n      slides\n    ),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, direction, container)\n  }\n\n  return engine\n}\n","export type NodeRectType = {\n  top: number\n  right: number\n  bottom: number\n  left: number\n  width: number\n  height: number\n}\n\nexport type NodeRectsType = {\n  measure: (node: HTMLElement) => NodeRectType\n}\n\nexport function NodeRects(): NodeRectsType {\n  function measure(node: HTMLElement): NodeRectType {\n    const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node\n    const offset: NodeRectType = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    }\n\n    return offset\n  }\n\n  const self: NodeRectsType = {\n    measure\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply\n  }\n  return self\n}\n","import { DirectionOptionType } from './Direction'\nimport { NodeRectType } from './NodeRects'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (nodeRect: NodeRectType) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(nodeRect: NodeRectType): number {\n    const { width, height } = nodeRect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure\n  }\n  return self\n}\n","import { isString } from './utils'\n\nexport type AlignmentOptionType =\n  | 'start'\n  | 'center'\n  | 'end'\n  | ((viewSize: number, snapSize: number, index: number) => number)\n\nexport type AlignmentType = {\n  measure: (n: number, index: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function measure(n: number, index: number): number {\n    if (isString(align)) return predefined[align](n)\n    return align(viewSize, n, index)\n  }\n\n  const self: AlignmentType = {\n    measure\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { arrayIsLastIndex, arrayLast, mathAbs, WindowType } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n  startGap: number\n  endGap: number\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n  ownerWindow: WindowType\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = ownerWindow.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(rects, index)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slidesToScroll: SlidesToScrollType\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayIsLastIndex, arrayLast } from './utils'\n\nexport type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n  scrollContainLimit: LimitType\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n  pixelTolerance: number\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, 0)\n  const snapsBounded = measureBounded()\n  const scrollContainLimit = findScrollContainLimit()\n  const snapsContained = measureContained()\n\n  function findScrollContainLimit(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureBounded(): number[] {\n    return snapsAligned\n      .map((snapAligned, index) => {\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(snapsAligned, index)\n        if (isFirst) return scrollBounds.max\n        if (isLast) return scrollBounds.min\n        return scrollBounds.constrain(snapAligned)\n      })\n      .map((scrollBound) => parseFloat(scrollBound.toFixed(3)))\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = scrollContainLimit\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n    scrollContainLimit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean\n): ScrollLimitType {\n  const max = scrollSnaps[0]\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps)\n  const limit = Limit(min, max)\n\n  const self: ScrollLimitType = {\n    limit\n  }\n  return self\n}\n","import { mathSign, mathAbs } from './utils'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  duration: () => number\n  velocity: () => number\n  seek: () => ScrollBodyType\n  settled: () => boolean\n  useBaseFriction: () => ScrollBodyType\n  useBaseDuration: () => ScrollBodyType\n  useFriction: (n: number) => ScrollBodyType\n  useDuration: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  offsetLocation: Vector1DType,\n  target: Vector1DType,\n  baseDuration: number,\n  baseFriction: number\n): ScrollBodyType {\n  let bodyVelocity = 0\n  let scrollDirection = 0\n  let scrollDuration = baseDuration\n  let scrollFriction = baseFriction\n  let rawLocation = location.get()\n  let rawLocationPrevious = 0\n\n  function seek(): ScrollBodyType {\n    const diff = target.get() - location.get()\n    const isInstant = !scrollDuration\n    let directionDiff = 0\n\n    if (isInstant) {\n      bodyVelocity = 0\n      location.set(target)\n\n      directionDiff = diff\n    } else {\n      bodyVelocity += diff / scrollDuration\n      bodyVelocity *= scrollFriction\n      rawLocation += bodyVelocity\n      location.add(bodyVelocity)\n\n      directionDiff = rawLocation - rawLocationPrevious\n    }\n\n    scrollDirection = mathSign(directionDiff)\n    rawLocationPrevious = rawLocation\n    return self\n  }\n\n  function settled(): boolean {\n    const diff = target.get() - offsetLocation.get()\n    return mathAbs(diff) < 0.001\n  }\n\n  function duration(): number {\n    return scrollDuration\n  }\n\n  function direction(): number {\n    return scrollDirection\n  }\n\n  function velocity(): number {\n    return bodyVelocity\n  }\n\n  function useBaseDuration(): ScrollBodyType {\n    return useDuration(baseDuration)\n  }\n\n  function useBaseFriction(): ScrollBodyType {\n    return useFriction(baseFriction)\n  }\n\n  function useDuration(n: number): ScrollBodyType {\n    scrollDuration = n\n    return self\n  }\n\n  function useFriction(n: number): ScrollBodyType {\n    scrollFriction = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  }\n  return self\n}\n","import { AnimationType } from './Animations'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    targetVector.add(distanceDiff)\n    if (distanceDiff) animation.start()\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return length ? currentLocation / -length : 0\n  }\n\n  const self: ScrollProgressType = {\n    get\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport {\n  arrayFromNumber,\n  arrayIsLastIndex,\n  arrayLast,\n  arrayLastIndex\n} from './utils'\n\nexport type SlideRegistryType = {\n  slideRegistry: number[][]\n}\n\nexport function SlideRegistry(\n  containSnaps: boolean,\n  containScroll: ScrollContainOptionType,\n  scrollSnaps: number[],\n  scrollContainLimit: LimitType,\n  slidesToScroll: SlidesToScrollType,\n  slideIndexes: number[]\n): SlideRegistryType {\n  const { groupSlides } = slidesToScroll\n  const { min, max } = scrollContainLimit\n  const slideRegistry = createSlideRegistry()\n\n  function createSlideRegistry(): number[][] {\n    const groupedSlideIndexes = groupSlides(slideIndexes)\n    const doNotContain = !containSnaps || containScroll === 'keepSnaps'\n\n    if (scrollSnaps.length === 1) return [slideIndexes]\n    if (doNotContain) return groupedSlideIndexes\n\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index\n      const isLast = arrayIsLastIndex(groups, index)\n\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1\n        return arrayFromNumber(range)\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1\n        return arrayFromNumber(range, arrayLast(groups)[0])\n      }\n      return group\n    })\n  }\n\n  const self: SlideRegistryType = {\n    slideRegistry\n  }\n  return self\n}\n","import { EventStoreType } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollToType } from './ScrollTo'\nimport { SlideRegistryType } from './SlideRegistry'\nimport { isNumber } from './utils'\n\nexport type SlideFocusType = {\n  init: () => void\n}\n\nexport function SlideFocus(\n  root: HTMLElement,\n  slides: HTMLElement[],\n  slideRegistry: SlideRegistryType['slideRegistry'],\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  eventStore: EventStoreType\n): SlideFocusType {\n  let lastTabPressTime = 0\n\n  function init(): void {\n    eventStore.add(document, 'keydown', registerTabPress, false)\n    slides.forEach(addSlideFocusEvent)\n  }\n\n  function registerTabPress(event: KeyboardEvent): void {\n    if (event.code === 'Tab') lastTabPressTime = new Date().getTime()\n  }\n\n  function addSlideFocusEvent(slide: HTMLElement): void {\n    const focus = (): void => {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n\n      if (diffTime > 10) return\n\n      root.scrollLeft = 0\n      const index = slides.indexOf(slide)\n      const group = slideRegistry.findIndex((group) => group.includes(index))\n\n      if (!isNumber(group)) return\n\n      scrollBody.useDuration(0)\n      scrollTo.index(group, 0)\n    }\n\n    eventStore.add(slide, 'focus', focus, {\n      passive: true,\n      capture: true\n    })\n  }\n\n  const self: SlideFocusType = {\n    init\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { DragHandlerOptionType } from './DragHandler'\nimport { ResizeHandlerOptionType } from './ResizeHandler'\nimport { SlidesHandlerOptionType } from './SlidesHandler'\nimport { SlidesInViewOptionsType } from './SlidesInView'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  container: string | HTMLElement | null\n  slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  dragThreshold: number\n  inViewThreshold: SlidesInViewOptionsType\n  loop: boolean\n  skipSnaps: boolean\n  duration: number\n  startIndex: number\n  watchDrag: DragHandlerOptionType\n  watchResize: ResizeHandlerOptionType\n  watchSlides: SlidesHandlerOptionType\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: 'trimSnaps',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsMergeDeep, WindowType } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ) => TypeA\n  optionsAtMedia: <Type extends OptionsType>(options: Type) => Type\n  optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[]\n}\n\nexport function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType {\n  function mergeOptions<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function optionsAtMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => ownerWindow.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => mergeOptions(a, mediaOption), {})\n\n    return mergeOptions(options, matchedMediaOptions)\n  }\n\n  function optionsMediaQueries(optionsList: OptionsType[]): MediaQueryList[] {\n    return optionsList\n      .map((options) => objectKeys(options.breakpoints || {}))\n      .reduce((acc, mediaQueries) => acc.concat(mediaQueries), [])\n      .map(ownerWindow.matchMedia)\n  }\n\n  const self: OptionsHandlerType = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { Animations, AnimationsType } from './Animations'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType, OptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\nimport { isString, WindowType } from './utils'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  emit: EventHandlerType['emit']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: () => number[]\n  slidesNotInView: () => number[]\n}\n\nfunction EmblaCarousel(\n  root: HTMLElement,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[]\n): EmblaCarouselType {\n  const ownerDocument = root.ownerDocument\n  const ownerWindow = <WindowType>ownerDocument.defaultView\n  const optionsHandler = OptionsHandler(ownerWindow)\n  const pluginsHandler = PluginsHandler(optionsHandler)\n  const mediaHandlers = EventStore()\n  const documentVisibleHandler = EventStore()\n  const eventHandler = EventHandler()\n  const { animationRealms } = EmblaCarousel\n  const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler\n  const { on, off, emit } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions)\n  let options = mergeOptions(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const { container: userContainer, slides: userSlides } = options\n\n    const customContainer = isString(userContainer)\n      ? root.querySelector(userContainer)\n      : userContainer\n    container = <HTMLElement>(customContainer || root.children[0])\n\n    const customSlides = isString(userSlides)\n      ? container.querySelectorAll(userSlides)\n      : userSlides\n    slides = <HTMLElement[]>[].slice.call(customSlides || container.children)\n  }\n\n  function createEngine(\n    options: OptionsType,\n    animations: AnimationsType\n  ): EngineType {\n    const engine = Engine(\n      root,\n      container,\n      slides,\n      ownerDocument,\n      ownerWindow,\n      options,\n      eventHandler,\n      animations\n    )\n\n    if (options.loop && !engine.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options, { loop: false })\n      return createEngine(optionsWithoutLoop, animations)\n    }\n    return engine\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    if (destroyed) return\n\n    const animationRealm = animationRealms.find((a) => a.window === ownerWindow)\n    const animations = animationRealm || Animations(ownerWindow)\n    if (!animationRealm) animationRealms.push(animations)\n\n    optionsBase = mergeOptions(optionsBase, withOptions)\n    options = optionsAtMedia(optionsBase)\n    pluginList = withPlugins || pluginList\n\n    storeElements()\n\n    engine = createEngine(options, animations)\n\n    optionsMediaQueries([\n      optionsBase,\n      ...pluginList.map(({ options }) => options)\n    ]).forEach((query) => mediaHandlers.add(query, 'change', reActivate))\n\n    if (!options.active) return\n\n    engine.translate.to(engine.location.get())\n    engine.slidesInView.init()\n    engine.slideFocus.init()\n    engine.eventHandler.init(self)\n    engine.resizeHandler.init(self)\n    engine.slidesHandler.init(self)\n\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.hidden) animations.reset()\n    })\n\n    if (engine.options.loop) engine.slideLooper.loop()\n    if (container.offsetParent && slides.length) engine.dragHandler.init(self)\n\n    pluginApis = pluginsHandler.init(self, pluginList)\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(mergeOptions({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.destroy()\n    engine.animation.stop()\n    engine.eventStore.clear()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    engine.resizeHandler.destroy()\n    engine.slidesHandler.destroy()\n    engine.slidesInView.destroy()\n    pluginsHandler.destroy()\n    mediaHandlers.clear()\n    documentVisibleHandler.clear()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    mediaHandlers.clear()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody\n      .useBaseFriction()\n      .useDuration(jump === true ? 0 : options.duration)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.add(1).get()\n    scrollTo(next, jump, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.add(-1).get()\n    scrollTo(prev, jump, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.add(1).get()\n    return next !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.add(-1).get()\n    return prev !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnapList\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function slidesInView(): number[] {\n    return engine.slidesInView.get()\n  }\n\n  function slidesNotInView(): number[] {\n    return engine.slidesInView.get(false)\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  }\n\n  activate(userOptions, userPlugins)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.animationRealms = <AnimationsType[]>[]\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default EmblaCarousel\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { OptionsHandlerType } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type PluginsHandlerType = {\n  init: (\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ) => EmblaPluginsType\n  destroy: () => void\n}\n\nexport function PluginsHandler(\n  optionsHandler: OptionsHandlerType\n): PluginsHandlerType {\n  let activePlugins: EmblaPluginType[] = []\n\n  function init(\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ): EmblaPluginsType {\n    activePlugins = plugins.filter(\n      ({ options }) => optionsHandler.optionsAtMedia(options).active !== false\n    )\n    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler))\n\n    return plugins.reduce(\n      (map, plugin) => Object.assign(map, { [plugin.name]: plugin }),\n      {}\n    )\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\n\ntype CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType = EmblaEventListType[keyof EmblaEventListType]\n\nexport interface EmblaEventListType {\n  init: 'init'\n  pointerDown: 'pointerDown'\n  pointerUp: 'pointerUp'\n  slidesChanged: 'slidesChanged'\n  slidesInView: 'slidesInView'\n  scroll: 'scroll'\n  select: 'select'\n  settle: 'settle'\n  destroy: 'destroy'\n  reInit: 'reInit'\n  resize: 'resize'\n}\n\nexport type EventHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n  let api: EmblaCarouselType\n\n  function init(emblaApi: EmblaCarouselType): void {\n    api = emblaApi\n  }\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(api, evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    init,\n    emit,\n    off,\n    on\n  }\n  return self\n}\n","import { EngineType } from './Engine'\nimport { mathAbs, WindowType } from './utils'\n\nexport type AnimationUpdateType = (engine: EngineType) => void\nexport type AnimationRenderType = (\n  engine: EngineType,\n  lagFactor: number\n) => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  update: () => void\n  render: (lagFactor: number) => void\n}\n\nexport type AnimationsType = {\n  start: (engine: EngineType) => void\n  stop: (engine: EngineType) => void\n  reset: () => void\n  window: WindowType\n}\n\nexport function Animations(ownerWindow: WindowType): AnimationsType {\n  const timeStep = 1000 / 60\n  let engines: EngineType[] = []\n  let lastTimeStamp: number | null = null\n  let lag = 0\n  let animationFrame = 0\n\n  function animate(timeStamp: DOMHighResTimeStamp): void {\n    if (!lastTimeStamp) lastTimeStamp = timeStamp\n\n    const elapsed = timeStamp - lastTimeStamp\n    lastTimeStamp = timeStamp\n    lag += elapsed\n\n    while (lag >= timeStep) {\n      engines.forEach(({ animation }) => animation.update())\n      lag -= timeStep\n    }\n\n    const lagOffset = mathAbs(lag / timeStep)\n    engines.forEach(({ animation }) => animation.render(lagOffset))\n\n    if (animationFrame) ownerWindow.requestAnimationFrame(animate)\n  }\n\n  function start(engine: EngineType): void {\n    if (!engines.includes(engine)) engines.push(engine)\n    if (animationFrame) return\n\n    animationFrame = ownerWindow.requestAnimationFrame(animate)\n  }\n\n  function stop(engine: EngineType): void {\n    engines = engines.filter((e) => e !== engine)\n    if (engines.length) return\n\n    ownerWindow.cancelAnimationFrame(animationFrame)\n    lastTimeStamp = null\n    lag = 0\n    animationFrame = 0\n  }\n\n  function reset(): void {\n    lastTimeStamp = null\n    lag = 0\n  }\n\n  const self: AnimationsType = {\n    start,\n    stop,\n    reset,\n    window: ownerWindow\n  }\n  return self\n}\n","import { useRef, useEffect, useState, useCallback } from 'react'\nimport {\n  areOptionsEqual,\n  arePluginsEqual,\n  canUseDOM\n} from 'embla-carousel-reactive-utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = []\n): UseEmblaCarouselType {\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [emblaApi, setEmblaApi] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current)\n  }, [emblaApi])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmblaApi = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current\n      )\n      setEmblaApi(newEmblaApi)\n      return () => newEmblaApi.destroy()\n    } else {\n      setEmblaApi(undefined)\n    }\n  }, [viewport, setEmblaApi])\n\n  useEffect(() => {\n    if (areOptionsEqual(storedOptions.current, options)) return\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, emblaApi]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n"],"names":["defaultOptions","active","breakpoints","delay","jump","playOnInit","stopOnFocusIn","stopOnInteraction","stopOnMouseEnter","stopOnLastSnap","rootNode","Autoplay","options","emblaApi","destroyed","userOptions","arguments","length","undefined","playing","resume","animationFrame","timer","startTimer","emit","ownerWindow","internalEngine","clearInterval","setInterval","next","clearTimer","play","jumpOverride","requestAnimationFrame","index","nextIndex","clone","add","get","lastIndex","scrollSnapList","canScrollNext","scrollNext","scrollTo","name","init","emblaApiInstance","optionsHandler","mergeOptions","optionsAtMedia","optionsBase","globalOptions","allOptions","eventStore","ownerDocument","emblaRoot","root","on","visibilityState","destroy","off","cancelAnimationFrame","stop","reset","isPlaying","isRecord","subject","Object","prototype","toString","call","isObject","Array","isArray","areOptionsEqual","optionsA","optionsB","optionsAKeys","keys","optionsBKeys","JSON","stringify","every","key","valueA","valueB","concat","sortAndMapPluginToOptions","plugins","sort","a","b","map","plugin","isNumber","isString","isBoolean","mathAbs","n","Math","abs","mathSign","sign","deltaAbs","arrayKeys","array","objectKeys","Number","arrayLast","arrayLastIndex","max","arrayIsLastIndex","arrayFromNumber","startAt","from","_","i","object","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","areObjects","isMouseEvent","evt","MouseEvent","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","start","loop","loopEnd","counter","withinLimit","self","set","EventStore","listeners","node","type","handler","removeListener","passive","addEventListener","removeEventListener","legacyMediaQueryList","addListener","push","clear","filter","remove","DragHandler","axis","direction","target","dragTracker","location","animation","scrollBody","scrollTarget","eventHandler","percentOfView","dragFree","dragThreshold","skipSnaps","baseFriction","watchDrag","cross","crossAxis","focusNodes","nonPassiveEvent","initEvents","dragEvents","goToNextThreshold","measure","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","isMoving","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","move","lastScroll","readPoint","lastCross","diffScroll","diffCross","cancelable","up","diff","pointerMove","useFriction","useDuration","apply","preventDefault","targetChanged","byDistance","rawForce","pointerUp","force","baseForce","distance","byIndex","allowedForce","forceFactor","factorAbs","speed","friction","click","stopPropagation","downIfAllowed","isMouseEvt","button","nodeName","includes","isFocusNode","buttons","pointerDown","addDragEvents","down","DragTracker","startEvent","lastEvent","readTime","timeStamp","evtAxis","property","scroll","coord","touches","expired","diffDrag","diffTime","ResizeHandler","container","slides","watchResize","nodeRects","resizeObserver","containerSize","slideSizes","readSize","measureSize","ResizeObserver","entries","entry","isContainer","slideIndex","indexOf","lastSize","reInit","defaultCallback","observe","disconnect","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","frictionLimit","disabled","edge","diffToEdge","diffToTarget","subtract","useBaseFriction","toggleActive","ScrollLooper","contentSize","offsetLocation","vectors","shouldLoop","loopDistance","v","ScrollTarget","scrollSnaps","targetVector","minDistance","distances","shortcut","targets","matchingTargets","t","snap","targetSnapDistance","ascDiffsToSnaps","scrollSnap","diffToSnap","d1","d2","findTargetSnap","reachedBound","Vector1D","initialValue","value","normalizeInput","Translate","translate","containerStyle","style","transform","getAttribute","removeAttribute","to","SlideLooper","viewSize","slideSizesWithGaps","snaps","roundingSafety","ascItems","descItems","reverse","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","removeSlideSizes","indexes","offset","isEndEdge","slideBounds","end","findSlideBounds","initial","altered","boundEdge","loopPoint","slideLocation","canLoop","_ref","shiftLocation","SlidesHandler","watchSlides","mutationObserver","MutationObserver","mutations","mutation","childList","SlidesInView","threshold","intersectionEntryMap","intersectionObserver","inViewCache","notInViewCache","IntersectionObserver","parentElement","slide","inView","slideIndexes","list","parseInt","isIntersecting","createInViewList","SlidesToScroll","slidesToScroll","containerRect","slideRects","startGap","endGap","pixelTolerance","startEdge","endEdge","groupByNumber","groupSlides","groupSize","slice","byNumber","groups","rectB","rectA","isFirst","isLast","edgeA","edgeB","gapA","currentSize","previousSize","bySize","Engine","animations","align","scrollAxis","contentDirection","startIndex","duration","inViewThreshold","containScroll","offsetTop","offsetLeft","offsetWidth","offsetHeight","top","right","bottom","left","width","height","Direction","nodeRect","Axis","PercentOfView","alignment","predefined","center","Alignment","containSnaps","readEdgeGap","withEdgeGap","slideRect","measureStartGap","getComputedStyle","parseFloat","getPropertyValue","measureEndGap","rect","rects","SlideSizes","snapsAligned","alignments","g","ScrollSnaps","snapsContained","scrollContainLimit","scrollBounds","snapsBounded","snapAligned","scrollBound","toFixed","startSnap","endSnap","lastIndexOf","findScrollContainLimit","measureContained","ScrollContain","ScrollLimit","indexPrevious","engine","update","_ref2","dragHandler","seek","render","lagOffset","_ref3","scrollLooper","slideLooper","velocity","hasSettled","settled","startLocation","baseDuration","bodyVelocity","scrollDirection","scrollDuration","scrollFriction","rawLocation","rawLocationPrevious","directionDiff","useBaseDuration","ScrollBody","indexCurrent","distanceDiff","indexDiff","targetIndex","ScrollTo","scrollProgress","ScrollProgress","slidesInView","slideRegistry","groupedSlideIndexes","doNotContain","group","createSlideRegistry","SlideRegistry","slideFocus","lastTabPressTime","registerTabPress","event","code","Date","getTime","addSlideFocusEvent","focus","scrollLeft","findIndex","capture","document","SlideFocus","resizeHandler","slidesHandler","OptionsHandler","matchedMediaOptions","media","matchMedia","matches","mediaOption","optionsMediaQueries","optionsList","acc","mediaQueries","EmblaCarousel","userPlugins","defaultView","pluginsHandler","activePlugins","_ref6","assign","PluginsHandler","mediaHandlers","documentVisibleHandler","api","getListeners","e","cb","EventHandler","animationRealms","reActivate","pluginApis","pluginList","createEngine","activate","withOptions","withPlugins","animationRealm","find","window","timeStep","engines","lastTimeStamp","lag","animate","elapsed","_ref4","_ref5","Animations","userContainer","userSlides","customContainer","querySelector","children","customSlides","querySelectorAll","storeElements","_ref7","query","hidden","offsetParent","selectedScrollSnap","deActivate","canScrollPrev","containerNode","previousScrollSnap","scrollPrev","slideNodes","slidesNotInView","setTimeout","useEmblaCarousel","storedOptions","useRef","storedPlugins","setEmblaApi","useState","viewport","setViewport","useCallback","current","useEffect","createElement","newEmblaApi","pluginsA","pluginsB","optionA","arePluginsEqual"],"sourceRoot":""}